# 面试问题临时整理

## 数据类型

- String

底层：简单动态字符串

内存开销大

- List

底层：双向链表，压缩列表

- Hash

底层：哈希表，压缩列表

- Set

底层：整数数组

- Sorted Set

底层：跳表

- 采用哈希表作为索引，简直数据都是在内存中保存

- **实现键值对的访问，使用了一个哈希表保存所有键值对**。哈希表就是一个数组，数组的每个元素称为一个哈希桶，**哈希桶保存的是指针**

- O(1)复杂度，计算建的哈希值，就能找到响应的元素

- 哈希冲突的办法的链式哈希，使用链表

## 底层原理

1. Redis单线程为啥这么快？？？ 

Redis的网络IO和键值对读写是单线程，持久化，集群数据同步有额外的线程。

- 单线程使用了IO复用机制。

- 合理的数据结构

- 内存数据库

2. 为啥使用单线程？

- 多线程的开销

- 共享资源的并发访问控制

## 集群应用

Redis具有高可靠性：数据少丢失（AOF+RDB），服务少中断（集群）

### 主从模式

主从库采用读写分离，使用**replicaof**命令

- 读操作：主库，从库都可以接受

- 写操作：先主库执行，同步给从库

### 哨兵机制

主库挂了，就需要运行一个新的主库，把一个从库切换为主库

哨兵机制解决：

主库真的挂了吗？该选择哪个从库作为主库？怎么把新主库的相关信息通知给从库和客户端呢？

**哨兵其实就是一个运行在特殊模式下的Redis进程，哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。**

- 监控

周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行

- 选主

主库挂了以后，哨兵就需要从很多个从库里，按照**一定的规则**选择一个从库实例

- 通知

哨兵会把新主库的连接信息发给其他从库，让它们执行replicaof命令，和新主库建立连接，并进行数据复制。

### 哨兵集群

通过部署多个实例，就形成了一个哨兵集群。

- 基于pub/sub机制的哨兵集群组成


### Redis-Cluster集群

切片集群：就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存

好处：降低节点的压力和单节点内存大小，每个节点的数据是不一致的，分布式的，共同承担整个redis集群查询操作

Redis-Cluster采用无中心结构,它的特点如下：

- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。

- 节点的fail是通过集群中超过半数的节点检测失效时才生效。

- 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

## 持久化

高并发场景会造成Redis性能抖动

### RDB（Redis Database）

内存快照，是指内存中的数据在某一个时刻的状态记录，快速恢复，全量快照

两种命令：

- save 主线程执行，会阻塞

- bgsave 子线程专门做，避免对性能影响

### AOF（Append Only File） 

日志，写后日志（先写入内存，再记录日志），不会阻塞当前的写操作，坏处是宕机后恢复慢

三种回写策略：

1. Always

2. EverySec(每秒回写性能最好)

3. No

## AOF和RDB总结

数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；

如果允许分钟级别的数据丢失，可以只使用 RDB；

如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。

## 缓存

- Redis 缓存具体是怎么工作的？
- Redis 缓存如果满了，该怎么办？
- 为什么会有缓存一致性、缓存穿透、缓存雪崩、缓存击穿等异常，该如何应对？

### 旁路缓存

我们也把 Redis 称为旁路缓存，也就是说，读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。

缓存类型：

- 只读缓存

- 读写缓存

### 缓存中的数据和数据库中的不一致

- 读写缓存

采用同步直写策略，**使用事务机制，来保证缓存和数据库的更新具有原子性。**

一致性的要求没有那么高，可以使用异步写回策略

- 只读缓存

重试机制：消息队列

### 缓存雪崩

缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。

- 缓存中有大量数据同时过期，导致大量请求无法得到处理。

我们可以避免给大量的数据设置相同的过期时间，或者服务降级

- Redis 缓存实例发生故障宕机了，无法处理请求

是在业务系统中实现服务熔断或请求限流机制。

### 缓存击穿

针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。**缓存击穿的情况，经常发生在热点数据过期失效时**

解决：对于访问特别频繁的热点数据，我们就不设置过期时间了

### 缓存穿透

缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据

**同时给缓存和数据库带来巨大压力**

解决：缓存空值，保住数据库

### 缓存污染

对于访问次数非常少的数据，访问者之后还留在缓存空间，这就是缓存污染

- LRU缓存淘汰策略

## 并发访问

### 分布式锁

分布式锁：锁是保存在一个共享存储系统中的，可以被多个客户端共享访问和获取。

```bash
SET lock_key random_value NX PX 5000
```

### 原子操作

- 把多个操作在 Redis 中实现成一个操作，也就是单命令操作；

Redis的INCR/DECR本身就具有原子性

- 把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。

